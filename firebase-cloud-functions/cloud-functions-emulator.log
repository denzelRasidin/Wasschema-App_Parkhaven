2018-04-07T12:01:42.000Z - info: User function triggered, starting execution
2018-04-07T12:01:42.005Z - info: Execution took 6 ms, user function completed successfully
2018-04-07T12:01:42.027Z - info: User function triggered, starting execution
2018-04-07T12:01:42.029Z - info: request.body:  { machineType: 'Laundrymachine',
  machine: 'A1',
  time: 6,
  room: 'A',
  idToken: 'eyJhbGciOiJSUzI1NiIsImtpZCI6IjZlYThhZmIwMjFjMjEzMDhjNzkzMDI2ZTMzNDA4ZGI3MDc2ODc0MWEifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vZmlyLTUzMWY0IiwibmFtZSI6IjQwMSIsImF1ZCI6ImZpci01MzFmNCIsImF1dGhfdGltZSI6MTUyMzEwMjQ5NiwidXNlcl9pZCI6IjNoYkIyY1FiNndodnRRdjJUdFhEbnlxZ1NEZjIiLCJzdWIiOiIzaGJCMmNRYjZ3aHZ0UXYyVHRYRG55cWdTRGYyIiwiaWF0IjoxNTIzMTAyNDk2LCJleHAiOjE1MjMxMDYwOTYsImVtYWlsIjoieW9zaC5uYWhhckBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsImZpcmViYXNlIjp7ImlkZW50aXRpZXMiOnsiZW1haWwiOlsieW9zaC5uYWhhckBnbWFpbC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.CY5MiK1ofuitSMPkcaSx-aTAN26i-H2QGDisO0VpnB22JcUIzKFYC5OWBWNK6KQ8OLTACZiO4grJ6CglvCMZ5U0CreY_mVN9oPsDuE6knc5jnprG9N9V565jdJtiUysI-u71TrzpFPzrRgTjBgfoJlfT-Kzern0XL5VXg74OJiyovSuoXYyz0cseFDCPbY7Ae3WEaWCJ2toImKSrjgPU8POKWYuxCTqsC_cZZfFKPcTfUwgq3rTRauqHUhrYzirdGzqVVtmjbt3dbP6YzMZNybF6qomIxsoQjpTwaZdMZ-3opRVuzRpSF60RF8FBhPq2f0Vkto0-y0XknnzXSi2OlQ',
  date: '26-04-2018',
  houseNumber: '-' }
2018-04-07T12:01:42.029Z - info: request.method:  PUT
2018-04-07T12:01:42.121Z - info: decodedToken: [object Object]
2018-04-07T12:01:42.126Z - info: Execution took 98 ms, user function completed successfully
2018-04-07T12:01:57.092Z - info: Worker for appointment closed due to file changes.
2018-04-07T12:01:59.562Z - info: User function triggered, starting execution
2018-04-07T12:01:59.568Z - info: Execution took 7 ms, user function completed successfully
2018-04-07T12:01:59.593Z - info: User function triggered, starting execution
2018-04-07T12:01:59.595Z - info: request.body:  { machineType: 'Laundrymachine',
  machine: 'A1',
  time: 6,
  room: 'A',
  idToken: 'eyJhbGciOiJSUzI1NiIsImtpZCI6IjZlYThhZmIwMjFjMjEzMDhjNzkzMDI2ZTMzNDA4ZGI3MDc2ODc0MWEifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vZmlyLTUzMWY0IiwibmFtZSI6IjQwMSIsImF1ZCI6ImZpci01MzFmNCIsImF1dGhfdGltZSI6MTUyMzEwMjQ5NiwidXNlcl9pZCI6IjNoYkIyY1FiNndodnRRdjJUdFhEbnlxZ1NEZjIiLCJzdWIiOiIzaGJCMmNRYjZ3aHZ0UXYyVHRYRG55cWdTRGYyIiwiaWF0IjoxNTIzMTAyNDk2LCJleHAiOjE1MjMxMDYwOTYsImVtYWlsIjoieW9zaC5uYWhhckBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsImZpcmViYXNlIjp7ImlkZW50aXRpZXMiOnsiZW1haWwiOlsieW9zaC5uYWhhckBnbWFpbC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.CY5MiK1ofuitSMPkcaSx-aTAN26i-H2QGDisO0VpnB22JcUIzKFYC5OWBWNK6KQ8OLTACZiO4grJ6CglvCMZ5U0CreY_mVN9oPsDuE6knc5jnprG9N9V565jdJtiUysI-u71TrzpFPzrRgTjBgfoJlfT-Kzern0XL5VXg74OJiyovSuoXYyz0cseFDCPbY7Ae3WEaWCJ2toImKSrjgPU8POKWYuxCTqsC_cZZfFKPcTfUwgq3rTRauqHUhrYzirdGzqVVtmjbt3dbP6YzMZNybF6qomIxsoQjpTwaZdMZ-3opRVuzRpSF60RF8FBhPq2f0Vkto0-y0XknnzXSi2OlQ',
  date: '26-04-2018',
  houseNumber: '-' }
request.method:  PUT
2018-04-07T12:01:59.678Z - info: decodedToken: [object Object]
2018-04-07T12:01:59.679Z - info: signedInUserUid 3hbB2cQb6whvtQv2TtXDnyqgSDf2
2018-04-07T12:01:59.685Z - info: Execution took 92 ms, user function completed successfully
2018-04-07T12:02:00.144Z - error: (node:7581) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 2): Error: Credential implementation provided to initializeApp() via the "credential" property has insufficient permission to access the requested resource. See https://firebase.google.com/docs/admin/setup for details on how to authenticate this SDK with appropriate permissions.
2018-04-07T12:02:00.145Z - error: (node:7581) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
2018-04-07T12:02:44.153Z - info: User function triggered, starting execution
2018-04-07T12:02:44.154Z - info: Execution took 1 ms, user function completed successfully
2018-04-07T12:02:44.162Z - info: User function triggered, starting execution
2018-04-07T12:02:44.162Z - info: request.body:  { machineType: 'Laundrymachine',
  machine: 'A1',
  time: 6,
  room: 'A',
  idToken: 'eyJhbGciOiJSUzI1NiIsImtpZCI6IjZlYThhZmIwMjFjMjEzMDhjNzkzMDI2ZTMzNDA4ZGI3MDc2ODc0MWEifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vZmlyLTUzMWY0IiwibmFtZSI6IjQwMSIsImF1ZCI6ImZpci01MzFmNCIsImF1dGhfdGltZSI6MTUyMzEwMjQ5NiwidXNlcl9pZCI6IjNoYkIyY1FiNndodnRRdjJUdFhEbnlxZ1NEZjIiLCJzdWIiOiIzaGJCMmNRYjZ3aHZ0UXYyVHRYRG55cWdTRGYyIiwiaWF0IjoxNTIzMTAyNDk2LCJleHAiOjE1MjMxMDYwOTYsImVtYWlsIjoieW9zaC5uYWhhckBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsImZpcmViYXNlIjp7ImlkZW50aXRpZXMiOnsiZW1haWwiOlsieW9zaC5uYWhhckBnbWFpbC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.CY5MiK1ofuitSMPkcaSx-aTAN26i-H2QGDisO0VpnB22JcUIzKFYC5OWBWNK6KQ8OLTACZiO4grJ6CglvCMZ5U0CreY_mVN9oPsDuE6knc5jnprG9N9V565jdJtiUysI-u71TrzpFPzrRgTjBgfoJlfT-Kzern0XL5VXg74OJiyovSuoXYyz0cseFDCPbY7Ae3WEaWCJ2toImKSrjgPU8POKWYuxCTqsC_cZZfFKPcTfUwgq3rTRauqHUhrYzirdGzqVVtmjbt3dbP6YzMZNybF6qomIxsoQjpTwaZdMZ-3opRVuzRpSF60RF8FBhPq2f0Vkto0-y0XknnzXSi2OlQ',
  date: '26-04-2018',
  houseNumber: '-' }
request.method:  PUT
2018-04-07T12:02:44.163Z - info: decodedToken: [object Object]
2018-04-07T12:02:44.163Z - info: signedInUserUid 3hbB2cQb6whvtQv2TtXDnyqgSDf2
2018-04-07T12:02:44.165Z - info: Execution took 3 ms, user function completed successfully
2018-04-07T12:02:44.589Z - error: (node:7581) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 4): Error: Credential implementation provided to initializeApp() via the "credential" property has insufficient permission to access the requested resource. See https://firebase.google.com/docs/admin/setup for details on how to authenticate this SDK with appropriate permissions.
2018-04-07T12:11:53.200Z - error: Function worker killed by signal: SIGTERM
2018-04-07T12:13:04.540Z - info: User function triggered, starting execution
2018-04-07T12:13:04.544Z - info: Execution took 6 ms, user function completed successfully
2018-04-07T12:13:04.559Z - info: User function triggered, starting execution
2018-04-07T12:13:04.561Z - info: request.body:  { machineType: 'Laundrymachine',
  machine: 'A1',
  time: 7,
  room: 'A',
  idToken: 'eyJhbGciOiJSUzI1NiIsImtpZCI6IjZlYThhZmIwMjFjMjEzMDhjNzkzMDI2ZTMzNDA4ZGI3MDc2ODc0MWEifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vZmlyLTUzMWY0IiwibmFtZSI6IjQwMSIsImF1ZCI6ImZpci01MzFmNCIsImF1dGhfdGltZSI6MTUyMzEwMjQ5NiwidXNlcl9pZCI6IjNoYkIyY1FiNndodnRRdjJUdFhEbnlxZ1NEZjIiLCJzdWIiOiIzaGJCMmNRYjZ3aHZ0UXYyVHRYRG55cWdTRGYyIiwiaWF0IjoxNTIzMTAyNDk2LCJleHAiOjE1MjMxMDYwOTYsImVtYWlsIjoieW9zaC5uYWhhckBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsImZpcmViYXNlIjp7ImlkZW50aXRpZXMiOnsiZW1haWwiOlsieW9zaC5uYWhhckBnbWFpbC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.CY5MiK1ofuitSMPkcaSx-aTAN26i-H2QGDisO0VpnB22JcUIzKFYC5OWBWNK6KQ8OLTACZiO4grJ6CglvCMZ5U0CreY_mVN9oPsDuE6knc5jnprG9N9V565jdJtiUysI-u71TrzpFPzrRgTjBgfoJlfT-Kzern0XL5VXg74OJiyovSuoXYyz0cseFDCPbY7Ae3WEaWCJ2toImKSrjgPU8POKWYuxCTqsC_cZZfFKPcTfUwgq3rTRauqHUhrYzirdGzqVVtmjbt3dbP6YzMZNybF6qomIxsoQjpTwaZdMZ-3opRVuzRpSF60RF8FBhPq2f0Vkto0-y0XknnzXSi2OlQ',
  date: '26-04-2018',
  houseNumber: '-' }
2018-04-07T12:13:04.562Z - info: request.method:  PUT
2018-04-07T12:13:04.624Z - info: decodedToken: [object Object]
2018-04-07T12:13:04.624Z - info: signedInUserUid 3hbB2cQb6whvtQv2TtXDnyqgSDf2
2018-04-07T12:13:04.630Z - info: Execution took 71 ms, user function completed successfully
2018-04-07T12:13:06.686Z - info: counter 0
2018-04-07T12:13:06.810Z - info: houseNumber -
2018-04-07T12:13:07.112Z - info: here
2018-04-07T12:13:10.011Z - info: User function triggered, starting execution
2018-04-07T12:13:10.013Z - info: Execution took 1 ms, user function completed successfully
2018-04-07T12:13:10.025Z - info: User function triggered, starting execution
request.body:  { machineType: 'Laundrymachine',
  machine: 'A1',
  time: 7,
  room: 'A',
  idToken: 'eyJhbGciOiJSUzI1NiIsImtpZCI6IjZlYThhZmIwMjFjMjEzMDhjNzkzMDI2ZTMzNDA4ZGI3MDc2ODc0MWEifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vZmlyLTUzMWY0IiwibmFtZSI6IjQwMSIsImF1ZCI6ImZpci01MzFmNCIsImF1dGhfdGltZSI6MTUyMzEwMjQ5NiwidXNlcl9pZCI6IjNoYkIyY1FiNndodnRRdjJUdFhEbnlxZ1NEZjIiLCJzdWIiOiIzaGJCMmNRYjZ3aHZ0UXYyVHRYRG55cWdTRGYyIiwiaWF0IjoxNTIzMTAyNDk2LCJleHAiOjE1MjMxMDYwOTYsImVtYWlsIjoieW9zaC5uYWhhckBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsImZpcmViYXNlIjp7ImlkZW50aXRpZXMiOnsiZW1haWwiOlsieW9zaC5uYWhhckBnbWFpbC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.CY5MiK1ofuitSMPkcaSx-aTAN26i-H2QGDisO0VpnB22JcUIzKFYC5OWBWNK6KQ8OLTACZiO4grJ6CglvCMZ5U0CreY_mVN9oPsDuE6knc5jnprG9N9V565jdJtiUysI-u71TrzpFPzrRgTjBgfoJlfT-Kzern0XL5VXg74OJiyovSuoXYyz0cseFDCPbY7Ae3WEaWCJ2toImKSrjgPU8POKWYuxCTqsC_cZZfFKPcTfUwgq3rTRauqHUhrYzirdGzqVVtmjbt3dbP6YzMZNybF6qomIxsoQjpTwaZdMZ-3opRVuzRpSF60RF8FBhPq2f0Vkto0-y0XknnzXSi2OlQ',
  date: '26-04-2018',
  houseNumber: '401' }
request.method:  PUT
decodedToken: [object Object]
signedInUserUid 3hbB2cQb6whvtQv2TtXDnyqgSDf2
2018-04-07T12:13:10.027Z - info: Execution took 6 ms, user function completed successfully
2018-04-07T12:13:10.548Z - info: counter 1
2018-04-07T12:13:10.754Z - info: houseNumber 401
2018-04-07T12:13:14.925Z - info: User function triggered, starting execution
2018-04-07T12:13:14.925Z - info: request.body:  { machineType: 'Laundrymachine',
  machine: 'A1',
  time: 7,
  room: 'A',
  idToken: 'eyJhbGciOiJSUzI1NiIsImtpZCI6IjZlYThhZmIwMjFjMjEzMDhjNzkzMDI2ZTMzNDA4ZGI3MDc2ODc0MWEifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vZmlyLTUzMWY0IiwibmFtZSI6IjQwMSIsImF1ZCI6ImZpci01MzFmNCIsImF1dGhfdGltZSI6MTUyMzEwMjQ5NiwidXNlcl9pZCI6IjNoYkIyY1FiNndodnRRdjJUdFhEbnlxZ1NEZjIiLCJzdWIiOiIzaGJCMmNRYjZ3aHZ0UXYyVHRYRG55cWdTRGYyIiwiaWF0IjoxNTIzMTAyNDk2LCJleHAiOjE1MjMxMDYwOTYsImVtYWlsIjoieW9zaC5uYWhhckBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsImZpcmViYXNlIjp7ImlkZW50aXRpZXMiOnsiZW1haWwiOlsieW9zaC5uYWhhckBnbWFpbC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.CY5MiK1ofuitSMPkcaSx-aTAN26i-H2QGDisO0VpnB22JcUIzKFYC5OWBWNK6KQ8OLTACZiO4grJ6CglvCMZ5U0CreY_mVN9oPsDuE6knc5jnprG9N9V565jdJtiUysI-u71TrzpFPzrRgTjBgfoJlfT-Kzern0XL5VXg74OJiyovSuoXYyz0cseFDCPbY7Ae3WEaWCJ2toImKSrjgPU8POKWYuxCTqsC_cZZfFKPcTfUwgq3rTRauqHUhrYzirdGzqVVtmjbt3dbP6YzMZNybF6qomIxsoQjpTwaZdMZ-3opRVuzRpSF60RF8FBhPq2f0Vkto0-y0XknnzXSi2OlQ',
  date: '26-04-2018',
  houseNumber: '-' }
request.method:  PUT
2018-04-07T12:13:14.927Z - info: decodedToken: [object Object]
signedInUserUid 3hbB2cQb6whvtQv2TtXDnyqgSDf2
2018-04-07T12:13:14.929Z - info: Execution took 4 ms, user function completed successfully
2018-04-07T12:13:15.361Z - info: counter 0
2018-04-07T12:13:15.482Z - info: houseNumber -
2018-04-07T12:13:15.788Z - info: here
2018-04-07T12:13:20.258Z - info: User function triggered, starting execution
2018-04-07T12:13:20.261Z - info: Execution took 1 ms, user function completed successfully
2018-04-07T12:13:20.270Z - info: User function triggered, starting execution
2018-04-07T12:13:20.270Z - info: request.body:  { machineType: 'Laundrymachine',
  machine: 'A1',
  time: 7,
  room: 'A',
  idToken: 'eyJhbGciOiJSUzI1NiIsImtpZCI6IjZlYThhZmIwMjFjMjEzMDhjNzkzMDI2ZTMzNDA4ZGI3MDc2ODc0MWEifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vZmlyLTUzMWY0IiwibmFtZSI6IjQwMSIsImF1ZCI6ImZpci01MzFmNCIsImF1dGhfdGltZSI6MTUyMzEwMjQ5NiwidXNlcl9pZCI6IjNoYkIyY1FiNndodnRRdjJUdFhEbnlxZ1NEZjIiLCJzdWIiOiIzaGJCMmNRYjZ3aHZ0UXYyVHRYRG55cWdTRGYyIiwiaWF0IjoxNTIzMTAyNDk2LCJleHAiOjE1MjMxMDYwOTYsImVtYWlsIjoieW9zaC5uYWhhckBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsImZpcmViYXNlIjp7ImlkZW50aXRpZXMiOnsiZW1haWwiOlsieW9zaC5uYWhhckBnbWFpbC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.CY5MiK1ofuitSMPkcaSx-aTAN26i-H2QGDisO0VpnB22JcUIzKFYC5OWBWNK6KQ8OLTACZiO4grJ6CglvCMZ5U0CreY_mVN9oPsDuE6knc5jnprG9N9V565jdJtiUysI-u71TrzpFPzrRgTjBgfoJlfT-Kzern0XL5VXg74OJiyovSuoXYyz0cseFDCPbY7Ae3WEaWCJ2toImKSrjgPU8POKWYuxCTqsC_cZZfFKPcTfUwgq3rTRauqHUhrYzirdGzqVVtmjbt3dbP6YzMZNybF6qomIxsoQjpTwaZdMZ-3opRVuzRpSF60RF8FBhPq2f0Vkto0-y0XknnzXSi2OlQ',
  date: '26-04-2018',
  houseNumber: '401' }
request.method:  PUT
2018-04-07T12:13:20.271Z - info: decodedToken: [object Object]
2018-04-07T12:13:20.271Z - info: signedInUserUid 3hbB2cQb6whvtQv2TtXDnyqgSDf2
2018-04-07T12:13:20.273Z - info: Execution took 2 ms, user function completed successfully
2018-04-07T12:13:20.684Z - info: counter 1
2018-04-07T12:13:20.890Z - info: houseNumber 401
2018-04-07T12:13:25.493Z - info: User function triggered, starting execution
2018-04-07T12:13:25.494Z - info: Execution took 1 ms, user function completed successfully
2018-04-07T12:13:25.504Z - info: User function triggered, starting execution
2018-04-07T12:13:25.504Z - info: request.body:  { machineType: 'Laundrymachine',
  machine: 'A1',
  time: 7,
  room: 'A',
  idToken: 'eyJhbGciOiJSUzI1NiIsImtpZCI6IjZlYThhZmIwMjFjMjEzMDhjNzkzMDI2ZTMzNDA4ZGI3MDc2ODc0MWEifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vZmlyLTUzMWY0IiwibmFtZSI6IjQwMSIsImF1ZCI6ImZpci01MzFmNCIsImF1dGhfdGltZSI6MTUyMzEwMjQ5NiwidXNlcl9pZCI6IjNoYkIyY1FiNndodnRRdjJUdFhEbnlxZ1NEZjIiLCJzdWIiOiIzaGJCMmNRYjZ3aHZ0UXYyVHRYRG55cWdTRGYyIiwiaWF0IjoxNTIzMTAyNDk2LCJleHAiOjE1MjMxMDYwOTYsImVtYWlsIjoieW9zaC5uYWhhckBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsImZpcmViYXNlIjp7ImlkZW50aXRpZXMiOnsiZW1haWwiOlsieW9zaC5uYWhhckBnbWFpbC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.CY5MiK1ofuitSMPkcaSx-aTAN26i-H2QGDisO0VpnB22JcUIzKFYC5OWBWNK6KQ8OLTACZiO4grJ6CglvCMZ5U0CreY_mVN9oPsDuE6knc5jnprG9N9V565jdJtiUysI-u71TrzpFPzrRgTjBgfoJlfT-Kzern0XL5VXg74OJiyovSuoXYyz0cseFDCPbY7Ae3WEaWCJ2toImKSrjgPU8POKWYuxCTqsC_cZZfFKPcTfUwgq3rTRauqHUhrYzirdGzqVVtmjbt3dbP6YzMZNybF6qomIxsoQjpTwaZdMZ-3opRVuzRpSF60RF8FBhPq2f0Vkto0-y0XknnzXSi2OlQ',
  date: '26-04-2018',
  houseNumber: '-' }
request.method:  PUT
2018-04-07T12:13:25.504Z - info: decodedToken: [object Object]
2018-04-07T12:13:25.505Z - info: signedInUserUid 3hbB2cQb6whvtQv2TtXDnyqgSDf2
2018-04-07T12:13:25.506Z - info: Execution took 2 ms, user function completed successfully
2018-04-07T12:13:25.794Z - info: User function triggered, starting execution
2018-04-07T12:13:25.794Z - info: request.body:  { machineType: 'Laundrymachine',
  machine: 'A2',
  time: 7,
  room: 'A',
  idToken: 'eyJhbGciOiJSUzI1NiIsImtpZCI6IjZlYThhZmIwMjFjMjEzMDhjNzkzMDI2ZTMzNDA4ZGI3MDc2ODc0MWEifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vZmlyLTUzMWY0IiwibmFtZSI6IjQwMSIsImF1ZCI6ImZpci01MzFmNCIsImF1dGhfdGltZSI6MTUyMzEwMjQ5NiwidXNlcl9pZCI6IjNoYkIyY1FiNndodnRRdjJUdFhEbnlxZ1NEZjIiLCJzdWIiOiIzaGJCMmNRYjZ3aHZ0UXYyVHRYRG55cWdTRGYyIiwiaWF0IjoxNTIzMTAyNDk2LCJleHAiOjE1MjMxMDYwOTYsImVtYWlsIjoieW9zaC5uYWhhckBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsImZpcmViYXNlIjp7ImlkZW50aXRpZXMiOnsiZW1haWwiOlsieW9zaC5uYWhhckBnbWFpbC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.CY5MiK1ofuitSMPkcaSx-aTAN26i-H2QGDisO0VpnB22JcUIzKFYC5OWBWNK6KQ8OLTACZiO4grJ6CglvCMZ5U0CreY_mVN9oPsDuE6knc5jnprG9N9V565jdJtiUysI-u71TrzpFPzrRgTjBgfoJlfT-Kzern0XL5VXg74OJiyovSuoXYyz0cseFDCPbY7Ae3WEaWCJ2toImKSrjgPU8POKWYuxCTqsC_cZZfFKPcTfUwgq3rTRauqHUhrYzirdGzqVVtmjbt3dbP6YzMZNybF6qomIxsoQjpTwaZdMZ-3opRVuzRpSF60RF8FBhPq2f0Vkto0-y0XknnzXSi2OlQ',
  date: '26-04-2018',
  houseNumber: '-' }
request.method:  PUT
2018-04-07T12:13:25.795Z - info: decodedToken: [object Object]
2018-04-07T12:13:25.795Z - info: signedInUserUid 3hbB2cQb6whvtQv2TtXDnyqgSDf2
2018-04-07T12:13:25.796Z - info: Execution took 2 ms, user function completed successfully
2018-04-07T12:13:25.926Z - info: counter 0
2018-04-07T12:13:26.046Z - info: houseNumber -
2018-04-07T12:13:26.047Z - info: counter 1
2018-04-07T12:13:26.126Z - info: User function triggered, starting execution
2018-04-07T12:13:26.126Z - info: request.body:  { machineType: 'Laundrymachine',
  machine: 'A2',
  time: 8,
  room: 'A',
  idToken: 'eyJhbGciOiJSUzI1NiIsImtpZCI6IjZlYThhZmIwMjFjMjEzMDhjNzkzMDI2ZTMzNDA4ZGI3MDc2ODc0MWEifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vZmlyLTUzMWY0IiwibmFtZSI6IjQwMSIsImF1ZCI6ImZpci01MzFmNCIsImF1dGhfdGltZSI6MTUyMzEwMjQ5NiwidXNlcl9pZCI6IjNoYkIyY1FiNndodnRRdjJUdFhEbnlxZ1NEZjIiLCJzdWIiOiIzaGJCMmNRYjZ3aHZ0UXYyVHRYRG55cWdTRGYyIiwiaWF0IjoxNTIzMTAyNDk2LCJleHAiOjE1MjMxMDYwOTYsImVtYWlsIjoieW9zaC5uYWhhckBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsImZpcmViYXNlIjp7ImlkZW50aXRpZXMiOnsiZW1haWwiOlsieW9zaC5uYWhhckBnbWFpbC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.CY5MiK1ofuitSMPkcaSx-aTAN26i-H2QGDisO0VpnB22JcUIzKFYC5OWBWNK6KQ8OLTACZiO4grJ6CglvCMZ5U0CreY_mVN9oPsDuE6knc5jnprG9N9V565jdJtiUysI-u71TrzpFPzrRgTjBgfoJlfT-Kzern0XL5VXg74OJiyovSuoXYyz0cseFDCPbY7Ae3WEaWCJ2toImKSrjgPU8POKWYuxCTqsC_cZZfFKPcTfUwgq3rTRauqHUhrYzirdGzqVVtmjbt3dbP6YzMZNybF6qomIxsoQjpTwaZdMZ-3opRVuzRpSF60RF8FBhPq2f0Vkto0-y0XknnzXSi2OlQ',
  date: '26-04-2018',
  houseNumber: '-' }
request.method:  PUT
2018-04-07T12:13:26.126Z - info: decodedToken: [object Object]
2018-04-07T12:13:26.127Z - info: signedInUserUid 3hbB2cQb6whvtQv2TtXDnyqgSDf2
2018-04-07T12:13:26.128Z - info: Execution took 2 ms, user function completed successfully
2018-04-07T12:13:26.172Z - info: houseNumber -
2018-04-07T12:13:26.287Z - info: here
2018-04-07T12:13:26.408Z - info: here
2018-04-07T12:13:26.409Z - info: User function triggered, starting execution
2018-04-07T12:13:26.409Z - info: request.body:  { machineType: 'Laundrymachine',
  machine: 'A1',
  time: 8,
  room: 'A',
  idToken: 'eyJhbGciOiJSUzI1NiIsImtpZCI6IjZlYThhZmIwMjFjMjEzMDhjNzkzMDI2ZTMzNDA4ZGI3MDc2ODc0MWEifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vZmlyLTUzMWY0IiwibmFtZSI6IjQwMSIsImF1ZCI6ImZpci01MzFmNCIsImF1dGhfdGltZSI6MTUyMzEwMjQ5NiwidXNlcl9pZCI6IjNoYkIyY1FiNndodnRRdjJUdFhEbnlxZ1NEZjIiLCJzdWIiOiIzaGJCMmNRYjZ3aHZ0UXYyVHRYRG55cWdTRGYyIiwiaWF0IjoxNTIzMTAyNDk2LCJleHAiOjE1MjMxMDYwOTYsImVtYWlsIjoieW9zaC5uYWhhckBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsImZpcmViYXNlIjp7ImlkZW50aXRpZXMiOnsiZW1haWwiOlsieW9zaC5uYWhhckBnbWFpbC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.CY5MiK1ofuitSMPkcaSx-aTAN26i-H2QGDisO0VpnB22JcUIzKFYC5OWBWNK6KQ8OLTACZiO4grJ6CglvCMZ5U0CreY_mVN9oPsDuE6knc5jnprG9N9V565jdJtiUysI-u71TrzpFPzrRgTjBgfoJlfT-Kzern0XL5VXg74OJiyovSuoXYyz0cseFDCPbY7Ae3WEaWCJ2toImKSrjgPU8POKWYuxCTqsC_cZZfFKPcTfUwgq3rTRauqHUhrYzirdGzqVVtmjbt3dbP6YzMZNybF6qomIxsoQjpTwaZdMZ-3opRVuzRpSF60RF8FBhPq2f0Vkto0-y0XknnzXSi2OlQ',
  date: '26-04-2018',
  houseNumber: '-' }
request.method:  PUT
2018-04-07T12:13:26.411Z - info: decodedToken: [object Object]
signedInUserUid 3hbB2cQb6whvtQv2TtXDnyqgSDf2
Execution took 1 ms, user function completed successfully
2018-04-07T12:13:26.467Z - info: counter 2
2018-04-07T12:13:26.586Z - info: houseNumber -
2018-04-07T12:13:26.606Z - info: counter 3
2018-04-07T12:13:26.609Z - error: (node:8758) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: Can't set headers after they are sent.
2018-04-07T12:13:26.609Z - error: (node:8758) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
2018-04-07T12:13:26.830Z - info: here
2018-04-07T12:13:27.259Z - info: User function triggered, starting execution
2018-04-07T12:13:27.259Z - info: request.body:  { machineType: 'Laundrymachine',
  machine: 'A1',
  time: 9,
  room: 'A',
  idToken: 'eyJhbGciOiJSUzI1NiIsImtpZCI6IjZlYThhZmIwMjFjMjEzMDhjNzkzMDI2ZTMzNDA4ZGI3MDc2ODc0MWEifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vZmlyLTUzMWY0IiwibmFtZSI6IjQwMSIsImF1ZCI6ImZpci01MzFmNCIsImF1dGhfdGltZSI6MTUyMzEwMjQ5NiwidXNlcl9pZCI6IjNoYkIyY1FiNndodnRRdjJUdFhEbnlxZ1NEZjIiLCJzdWIiOiIzaGJCMmNRYjZ3aHZ0UXYyVHRYRG55cWdTRGYyIiwiaWF0IjoxNTIzMTAyNDk2LCJleHAiOjE1MjMxMDYwOTYsImVtYWlsIjoieW9zaC5uYWhhckBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsImZpcmViYXNlIjp7ImlkZW50aXRpZXMiOnsiZW1haWwiOlsieW9zaC5uYWhhckBnbWFpbC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.CY5MiK1ofuitSMPkcaSx-aTAN26i-H2QGDisO0VpnB22JcUIzKFYC5OWBWNK6KQ8OLTACZiO4grJ6CglvCMZ5U0CreY_mVN9oPsDuE6knc5jnprG9N9V565jdJtiUysI-u71TrzpFPzrRgTjBgfoJlfT-Kzern0XL5VXg74OJiyovSuoXYyz0cseFDCPbY7Ae3WEaWCJ2toImKSrjgPU8POKWYuxCTqsC_cZZfFKPcTfUwgq3rTRauqHUhrYzirdGzqVVtmjbt3dbP6YzMZNybF6qomIxsoQjpTwaZdMZ-3opRVuzRpSF60RF8FBhPq2f0Vkto0-y0XknnzXSi2OlQ',
  date: '26-04-2018',
  houseNumber: '-' }
request.method:  PUT
2018-04-07T12:13:27.261Z - info: decodedToken: [object Object]
signedInUserUid 3hbB2cQb6whvtQv2TtXDnyqgSDf2
Execution took 2 ms, user function completed successfully
2018-04-07T12:13:27.495Z - info: User function triggered, starting execution
2018-04-07T12:13:27.496Z - info: request.body:  { machineType: 'Laundrymachine',
  machine: 'A2',
  time: 9,
  room: 'A',
  idToken: 'eyJhbGciOiJSUzI1NiIsImtpZCI6IjZlYThhZmIwMjFjMjEzMDhjNzkzMDI2ZTMzNDA4ZGI3MDc2ODc0MWEifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vZmlyLTUzMWY0IiwibmFtZSI6IjQwMSIsImF1ZCI6ImZpci01MzFmNCIsImF1dGhfdGltZSI6MTUyMzEwMjQ5NiwidXNlcl9pZCI6IjNoYkIyY1FiNndodnRRdjJUdFhEbnlxZ1NEZjIiLCJzdWIiOiIzaGJCMmNRYjZ3aHZ0UXYyVHRYRG55cWdTRGYyIiwiaWF0IjoxNTIzMTAyNDk2LCJleHAiOjE1MjMxMDYwOTYsImVtYWlsIjoieW9zaC5uYWhhckBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsImZpcmViYXNlIjp7ImlkZW50aXRpZXMiOnsiZW1haWwiOlsieW9zaC5uYWhhckBnbWFpbC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.CY5MiK1ofuitSMPkcaSx-aTAN26i-H2QGDisO0VpnB22JcUIzKFYC5OWBWNK6KQ8OLTACZiO4grJ6CglvCMZ5U0CreY_mVN9oPsDuE6knc5jnprG9N9V565jdJtiUysI-u71TrzpFPzrRgTjBgfoJlfT-Kzern0XL5VXg74OJiyovSuoXYyz0cseFDCPbY7Ae3WEaWCJ2toImKSrjgPU8POKWYuxCTqsC_cZZfFKPcTfUwgq3rTRauqHUhrYzirdGzqVVtmjbt3dbP6YzMZNybF6qomIxsoQjpTwaZdMZ-3opRVuzRpSF60RF8FBhPq2f0Vkto0-y0XknnzXSi2OlQ',
  date: '26-04-2018',
  houseNumber: '-' }
request.method:  PUT
2018-04-07T12:13:27.497Z - info: decodedToken: [object Object]
2018-04-07T12:13:27.497Z - info: signedInUserUid 3hbB2cQb6whvtQv2TtXDnyqgSDf2
2018-04-07T12:13:27.499Z - info: Execution took 3 ms, user function completed successfully
2018-04-07T12:13:27.626Z - info: counter 3
2018-04-07T12:13:27.626Z - error: (node:8758) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 2): Error: Can't set headers after they are sent.
2018-04-07T12:13:27.789Z - info: counter 3
2018-04-07T12:13:27.789Z - error: (node:8758) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 3): Error: Can't set headers after they are sent.
2018-04-07T12:13:30.725Z - info: User function triggered, starting execution
2018-04-07T12:13:30.726Z - info: Execution took 1 ms, user function completed successfully
2018-04-07T12:13:30.734Z - info: User function triggered, starting execution
2018-04-07T12:13:30.734Z - info: request.body:  { machineType: 'Laundrymachine',
  machine: 'A1',
  time: 7,
  room: 'A',
  idToken: 'eyJhbGciOiJSUzI1NiIsImtpZCI6IjZlYThhZmIwMjFjMjEzMDhjNzkzMDI2ZTMzNDA4ZGI3MDc2ODc0MWEifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vZmlyLTUzMWY0IiwibmFtZSI6IjQwMSIsImF1ZCI6ImZpci01MzFmNCIsImF1dGhfdGltZSI6MTUyMzEwMjQ5NiwidXNlcl9pZCI6IjNoYkIyY1FiNndodnRRdjJUdFhEbnlxZ1NEZjIiLCJzdWIiOiIzaGJCMmNRYjZ3aHZ0UXYyVHRYRG55cWdTRGYyIiwiaWF0IjoxNTIzMTAyNDk2LCJleHAiOjE1MjMxMDYwOTYsImVtYWlsIjoieW9zaC5uYWhhckBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsImZpcmViYXNlIjp7ImlkZW50aXRpZXMiOnsiZW1haWwiOlsieW9zaC5uYWhhckBnbWFpbC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.CY5MiK1ofuitSMPkcaSx-aTAN26i-H2QGDisO0VpnB22JcUIzKFYC5OWBWNK6KQ8OLTACZiO4grJ6CglvCMZ5U0CreY_mVN9oPsDuE6knc5jnprG9N9V565jdJtiUysI-u71TrzpFPzrRgTjBgfoJlfT-Kzern0XL5VXg74OJiyovSuoXYyz0cseFDCPbY7Ae3WEaWCJ2toImKSrjgPU8POKWYuxCTqsC_cZZfFKPcTfUwgq3rTRauqHUhrYzirdGzqVVtmjbt3dbP6YzMZNybF6qomIxsoQjpTwaZdMZ-3opRVuzRpSF60RF8FBhPq2f0Vkto0-y0XknnzXSi2OlQ',
  date: '26-04-2018',
  houseNumber: '401' }
request.method:  PUT
2018-04-07T12:13:30.735Z - info: decodedToken: [object Object]
2018-04-07T12:13:30.735Z - info: signedInUserUid 3hbB2cQb6whvtQv2TtXDnyqgSDf2
2018-04-07T12:13:30.737Z - info: Execution took 2 ms, user function completed successfully
2018-04-07T12:13:30.906Z - info: User function triggered, starting execution
2018-04-07T12:13:30.906Z - info: request.body:  { machineType: 'Laundrymachine',
  machine: 'A2',
  time: 7,
  room: 'A',
  idToken: 'eyJhbGciOiJSUzI1NiIsImtpZCI6IjZlYThhZmIwMjFjMjEzMDhjNzkzMDI2ZTMzNDA4ZGI3MDc2ODc0MWEifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vZmlyLTUzMWY0IiwibmFtZSI6IjQwMSIsImF1ZCI6ImZpci01MzFmNCIsImF1dGhfdGltZSI6MTUyMzEwMjQ5NiwidXNlcl9pZCI6IjNoYkIyY1FiNndodnRRdjJUdFhEbnlxZ1NEZjIiLCJzdWIiOiIzaGJCMmNRYjZ3aHZ0UXYyVHRYRG55cWdTRGYyIiwiaWF0IjoxNTIzMTAyNDk2LCJleHAiOjE1MjMxMDYwOTYsImVtYWlsIjoieW9zaC5uYWhhckBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsImZpcmViYXNlIjp7ImlkZW50aXRpZXMiOnsiZW1haWwiOlsieW9zaC5uYWhhckBnbWFpbC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.CY5MiK1ofuitSMPkcaSx-aTAN26i-H2QGDisO0VpnB22JcUIzKFYC5OWBWNK6KQ8OLTACZiO4grJ6CglvCMZ5U0CreY_mVN9oPsDuE6knc5jnprG9N9V565jdJtiUysI-u71TrzpFPzrRgTjBgfoJlfT-Kzern0XL5VXg74OJiyovSuoXYyz0cseFDCPbY7Ae3WEaWCJ2toImKSrjgPU8POKWYuxCTqsC_cZZfFKPcTfUwgq3rTRauqHUhrYzirdGzqVVtmjbt3dbP6YzMZNybF6qomIxsoQjpTwaZdMZ-3opRVuzRpSF60RF8FBhPq2f0Vkto0-y0XknnzXSi2OlQ',
  date: '26-04-2018',
  houseNumber: '401' }
request.method:  PUT
2018-04-07T12:13:30.908Z - info: decodedToken: [object Object]
2018-04-07T12:13:30.908Z - info: signedInUserUid 3hbB2cQb6whvtQv2TtXDnyqgSDf2
2018-04-07T12:13:30.909Z - info: Execution took 3 ms, user function completed successfully
2018-04-07T12:13:31.050Z - info: counter 3
2018-04-07T12:13:31.130Z - info: User function triggered, starting execution
2018-04-07T12:13:31.130Z - info: request.body:  { machineType: 'Laundrymachine',
  machine: 'A2',
  time: 8,
  room: 'A',
  idToken: 'eyJhbGciOiJSUzI1NiIsImtpZCI6IjZlYThhZmIwMjFjMjEzMDhjNzkzMDI2ZTMzNDA4ZGI3MDc2ODc0MWEifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vZmlyLTUzMWY0IiwibmFtZSI6IjQwMSIsImF1ZCI6ImZpci01MzFmNCIsImF1dGhfdGltZSI6MTUyMzEwMjQ5NiwidXNlcl9pZCI6IjNoYkIyY1FiNndodnRRdjJUdFhEbnlxZ1NEZjIiLCJzdWIiOiIzaGJCMmNRYjZ3aHZ0UXYyVHRYRG55cWdTRGYyIiwiaWF0IjoxNTIzMTAyNDk2LCJleHAiOjE1MjMxMDYwOTYsImVtYWlsIjoieW9zaC5uYWhhckBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsImZpcmViYXNlIjp7ImlkZW50aXRpZXMiOnsiZW1haWwiOlsieW9zaC5uYWhhckBnbWFpbC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.CY5MiK1ofuitSMPkcaSx-aTAN26i-H2QGDisO0VpnB22JcUIzKFYC5OWBWNK6KQ8OLTACZiO4grJ6CglvCMZ5U0CreY_mVN9oPsDuE6knc5jnprG9N9V565jdJtiUysI-u71TrzpFPzrRgTjBgfoJlfT-Kzern0XL5VXg74OJiyovSuoXYyz0cseFDCPbY7Ae3WEaWCJ2toImKSrjgPU8POKWYuxCTqsC_cZZfFKPcTfUwgq3rTRauqHUhrYzirdGzqVVtmjbt3dbP6YzMZNybF6qomIxsoQjpTwaZdMZ-3opRVuzRpSF60RF8FBhPq2f0Vkto0-y0XknnzXSi2OlQ',
  date: '26-04-2018',
  houseNumber: '401' }
request.method:  PUT
2018-04-07T12:13:31.132Z - info: decodedToken: [object Object]
2018-04-07T12:13:31.132Z - info: signedInUserUid 3hbB2cQb6whvtQv2TtXDnyqgSDf2
2018-04-07T12:13:31.133Z - info: Execution took 3 ms, user function completed successfully
2018-04-07T12:13:31.168Z - info: houseNumber 401
2018-04-07T12:13:31.168Z - info: counter 2
2018-04-07T12:13:31.287Z - info: houseNumber 401
2018-04-07T12:13:31.354Z - info: counter 1
2018-04-07T12:13:31.473Z - info: houseNumber 401
2018-04-07T12:22:58.898Z - error: Function worker killed by signal: SIGTERM
2018-04-07T12:44:58.584Z - info: User function triggered, starting execution
2018-04-07T12:44:58.586Z - info: request.body:  {}
request.method:  GET
2018-04-07T12:44:58.588Z - info: Function crashed
2018-04-07T12:44:58.589Z - info: { Error: First argument to verifyIdToken() must be a Firebase ID token string.
    at FirebaseAuthError.FirebaseError [as constructor] (/home/yoshua/Development/GitHub/Wasschema-App_Parkhaven/firebase-cloud-functions/functions/node_modules/firebase-admin/lib/utils/error.js:39:28)
    at FirebaseAuthError.PrefixedFirebaseError [as constructor] (/home/yoshua/Development/GitHub/Wasschema-App_Parkhaven/firebase-cloud-functions/functions/node_modules/firebase-admin/lib/utils/error.js:85:28)
    at new FirebaseAuthError (/home/yoshua/Development/GitHub/Wasschema-App_Parkhaven/firebase-cloud-functions/functions/node_modules/firebase-admin/lib/utils/error.js:143:16)
    at FirebaseTokenVerifier.verifyJWT (/home/yoshua/Development/GitHub/Wasschema-App_Parkhaven/firebase-cloud-functions/functions/node_modules/firebase-admin/lib/auth/token-verifier.js:76:19)
    at FirebaseTokenGenerator.verifyIdToken (/home/yoshua/Development/GitHub/Wasschema-App_Parkhaven/firebase-cloud-functions/functions/node_modules/firebase-admin/lib/auth/token-generator.js:129:37)
    at Auth.verifyIdToken (/home/yoshua/Development/GitHub/Wasschema-App_Parkhaven/firebase-cloud-functions/functions/node_modules/firebase-admin/lib/auth/auth.js:124:37)
    at cors (/home/yoshua/Development/GitHub/Wasschema-App_Parkhaven/firebase-cloud-functions/functions/index.js:35:18)
    at cors (/home/yoshua/Development/GitHub/Wasschema-App_Parkhaven/firebase-cloud-functions/functions/node_modules/cors/lib/index.js:188:7)
    at /home/yoshua/Development/GitHub/Wasschema-App_Parkhaven/firebase-cloud-functions/functions/node_modules/cors/lib/index.js:224:17
    at originCallback (/home/yoshua/Development/GitHub/Wasschema-App_Parkhaven/firebase-cloud-functions/functions/node_modules/cors/lib/index.js:214:15)
  errorInfo: 
   { code: 'auth/argument-error',
     message: 'First argument to verifyIdToken() must be a Firebase ID token string.' },
  codePrefix: 'auth' }
2018-04-07T12:44:58.600Z - info: Execution took 17 ms, user function completed successfully
2018-04-07T12:45:12.165Z - info: User function triggered, starting execution
2018-04-07T12:45:12.165Z - info: GET
2018-04-07T12:45:12.169Z - info: Execution took 5 ms, user function completed successfully
2018-04-07T12:45:17.412Z - info: User function triggered, starting execution
2018-04-07T12:45:17.412Z - info: POST
2018-04-07T12:45:17.413Z - info: Execution took 0 ms, user function completed successfully
2018-04-07T12:45:28.027Z - info: User function triggered, starting execution
PUT
2018-04-07T12:45:28.028Z - info: Execution took 1 ms, user function completed successfully
2018-04-07T12:45:39.448Z - info: User function triggered, starting execution
PATCH
2018-04-07T12:45:39.448Z - info: Execution took 0 ms, user function completed successfully
2018-04-07T12:45:43.443Z - info: User function triggered, starting execution
DELETE
2018-04-07T12:45:43.444Z - info: Execution took 1 ms, user function completed successfully
2018-04-07T12:45:47.481Z - info: User function triggered, starting execution
COPY
2018-04-07T12:45:47.481Z - info: Execution took 0 ms, user function completed successfully
2018-04-07T12:45:51.083Z - info: User function triggered, starting execution
HEAD
2018-04-07T12:45:51.083Z - info: Execution took 0 ms, user function completed successfully
2018-04-07T12:45:55.474Z - info: User function triggered, starting execution
2018-04-07T12:45:55.475Z - info: OPTIONS
Execution took 1 ms, user function completed successfully
2018-04-07T12:46:02.818Z - info: User function triggered, starting execution
2018-04-07T12:46:02.818Z - info: LINK
2018-04-07T12:46:02.819Z - info: Execution took 0 ms, user function completed successfully
2018-04-07T12:46:09.182Z - info: User function triggered, starting execution
UNLINK
2018-04-07T12:46:09.182Z - info: Execution took 1 ms, user function completed successfully
2018-04-07T12:46:12.826Z - info: User function triggered, starting execution
2018-04-07T12:46:12.826Z - info: PURGE
Execution took 0 ms, user function completed successfully
2018-04-07T12:46:16.288Z - info: User function triggered, starting execution
2018-04-07T12:46:16.289Z - info: LOCK
Execution took 1 ms, user function completed successfully
2018-04-07T12:46:21.770Z - info: User function triggered, starting execution
2018-04-07T12:46:21.770Z - info: UNLOCK
Execution took 0 ms, user function completed successfully
2018-04-07T12:46:25.211Z - error: SUPERVISOR clientError { Error: Parse Error bytesParsed: 0, code: 'HPE_INVALID_METHOD' } connecting=false, _hadError=false, reading=true, $ref=$, onread=function onread(nread, buffer) {
  var handle = this;
  var self = handle.owner;
  assert(handle === self._handle, 'handle != self._handle');

  self._unrefTimer();

  debug('onread', nread);

  if (nread > 0) {
    debug('got data');

    // read success.
    // In theory (and in practice) calling readStop right now
    // will prevent this from being called again until _read() gets
    // called again.

    // Optimization: emit the original buffer with end points
    var ret = self.push(buffer);

    if (handle.reading && !ret) {
      handle.reading = false;
      debug('readStop');
      var err = handle.readStop();
      if (err)
        self.destroy(errnoException(err, 'read'));
    }
    return;
  }

  // if we didn't get any bytes, that doesn't necessarily mean EOF.
  // wait for the next one.
  if (nread === 0) {
    debug('not any data, keep waiting');
    return;
  }

  // Error, possibly EOF.
  if (nread !== uv.UV_EOF) {
    return self.destroy(errnoException(nread, 'read'));
  }

  debug('EOF');

  // push a null to signal the end of data.
  // Do it before `maybeDestroy` for correct order of events:
  // `end` -> `close`
  self.push(null);

  if (self._readableState.length === 0) {
    self.readable = false;
    maybeDestroy(self);
  }

  // internal end event so that we know that the actual socket
  // is no longer readable, and we can start the shutdown
  // procedure. No need to wait for all the data to be consumed.
  self.emit('_socketEnd');
}, onconnection=null, writeQueueSize=0, _consumed=true, _parent=null, _host=null, objectMode=false, highWaterMark=16384, head=null, tail=null, length=0, length=0, pipes=null, pipesCount=0, flowing=true, ended=false, endEmitted=false, reading=true, sync=false, needReadable=true, emittedReadable=false, readableListening=false, resumeScheduled=false, destroyed=false, defaultEncoding=utf8, awaitDrain=0, readingMore=false, decoder=null, encoding=null, readable=true, domain=null, end=[function () { [native code] }, function () { [native code] }], finish=function onSocketFinish() {
  // If still connecting - defer handling 'finish' until 'connect' will happen
  if (this.connecting) {
    debug('osF: not yet connected');
    return this.once('connect', onSocketFinish);
  }

  debug('onSocketFinish');
  if (!this.readable || this._readableState.ended) {
    debug('oSF: ended, destroy', this._readableState);
    return this.destroy();
  }

  debug('oSF: not ended, call shutdown()');

  // otherwise, just shutdown, or destroy() if not possible
  if (!this._handle || !this._handle.shutdown)
    return this.destroy();

  var req = new ShutdownWrap();
  req.oncomplete = afterShutdown;
  req.handle = this._handle;
  // node::ShutdownWrap isn't instantiated and attached to the JS instance of
  // ShutdownWrap above until shutdown() is called. So don't set the init
  // trigger id until now.
  setInitTriggerId(this[async_id_symbol]);
  var err = this._handle.shutdown(req);

  if (err)
    return this.destroy(errnoException(err, 'shutdown'));
}, _socketEnd=function onSocketEnd() {
  // XXX Should not have to do as much in this function.
  // ended should already be true, since this is called *after*
  // the EOF errno and onread has eof'ed
  debug('onSocketEnd', this._readableState);
  this._readableState.ended = true;
  if (this._readableState.endEmitted) {
    this.readable = false;
    maybeDestroy(this);
  } else {
    this.once('end', function end() {
      this.readable = false;
      maybeDestroy(this);
    });
    this.read(0);
  }

  if (!this.allowHalfOpen) {
    this.write = writeAfterFIN;
    this.destroySoon();
  }
}, drain=[function ondrain() {
  if (this._httpMessage) this._httpMessage.emit('drain');
}, function () { [native code] }], timeout=function socketOnTimeout() {
  var req = this.parser && this.parser.incoming;
  var reqTimeout = req && !req.complete && req.emit('timeout', this);
  var res = this._httpMessage;
  var resTimeout = res && res.emit('timeout', this);
  var serverTimeout = this.server.emit('timeout', this);

  if (!reqTimeout && !resTimeout && !serverTimeout)
    this.destroy();
}, data=function () { [native code] }, close=function () { [native code] }, resume=function onSocketResume() {
  // It may seem that the socket is resumed, but this is an enemy's trick to
  // deceive us! `resume` is emitted asynchronously, and may be called from
  // `incoming.readStart()`. Stop the socket again here, just to preserve the
  // state.
  //
  // We don't care about stream semantics for the consumed socket anyway.
  if (this._paused) {
    this.pause();
    return;
  }

  if (this._handle && !this._handle.reading) {
    this._handle.reading = true;
    this._handle.readStart();
  }
}, pause=function onSocketPause() {
  if (this._handle && this._handle.reading) {
    this._handle.reading = false;
    this._handle.readStop();
  }
}, error=() => {}, _eventsCount=10, _maxListeners=undefined, objectMode=false, highWaterMark=16384, finalCalled=false, needDrain=false, ending=false, ended=false, finished=false, destroyed=false, decodeStrings=false, defaultEncoding=utf8, length=0, writing=false, corked=0, sync=true, bufferProcessing=false, onwrite=function () { [native code] }, writecb=null, writelen=0, bufferedRequest=null, lastBufferedRequest=null, pendingcb=0, prefinished=false, errorEmitted=false, bufferedRequestCount=0, next=null, entry=null, finish=function () { [native code] }, writable=true, allowHalfOpen=true, _bytesDispatched=0, _sockname=null, _pendingData=null, _pendingEncoding=, domain=null, request=function (req, res, next) {
    app.handle(req, res, next);
  }, connection=function connectionListener(socket) {
  debug('SERVER new http connection');

  httpSocketSetup(socket);

  // Ensure that the server property of the socket is correctly set.
  // See https://github.com/nodejs/node/issues/13435
  if (socket.server === null)
    socket.server = this;

  // If the user has added a listener to the server,
  // request, or response, then it's their responsibility.
  // otherwise, destroy on timeout by default
  if (this.timeout)
    socket.setTimeout(this.timeout);
  socket.on('timeout', socketOnTimeout);

  var parser = parsers.alloc();
  parser.reinitialize(HTTPParser.REQUEST);
  parser.socket = socket;
  socket.parser = parser;
  parser.incoming = null;

  // Propagate headers limit from server instance to parser
  if (typeof this.maxHeadersCount === 'number') {
    parser.maxHeaderPairs = this.maxHeadersCount << 1;
  } else {
    // Set default value because parser may be reused from FreeList
    parser.maxHeaderPairs = 2000;
  }

  var state = {
    onData: null,
    onEnd: null,
    onClose: null,
    onDrain: null,
    outgoing: [],
    incoming: [],
    // `outgoingData` is an approximate amount of bytes queued through all
    // inactive responses. If more data than the high watermark is queued - we
    // need to pause TCP socket/HTTP parser, and wait until the data will be
    // sent to the client.
    outgoingData: 0,
    keepAliveTimeoutSet: false
  };
  state.onData = socketOnData.bind(undefined, this, socket, parser, state);
  state.onEnd = socketOnEnd.bind(undefined, this, socket, parser, state);
  state.onClose = socketOnClose.bind(undefined, socket, state);
  state.onDrain = socketOnDrain.bind(undefined, socket, state);
  socket.on('data', state.onData);
  socket.on('error', socketOnError);
  socket.on('end', state.onEnd);
  socket.on('close', state.onClose);
  socket.on('drain', state.onDrain);
  parser.onIncoming = parserOnIncoming.bind(undefined, this, socket, state);

  // We are consuming socket, so it won't get any actual data
  socket.on('resume', onSocketResume);
  socket.on('pause', onSocketPause);

  // Override on to unconsume on `data`, `readable` listeners
  socket.on = socketOnWrap;

  // We only consume the socket if it has never been consumed before.
  var external = socket._handle._externalStream;
  if (!socket._handle._consumed && external) {
    parser._consumed = true;
    socket._handle._consumed = true;
    parser.consume(external);
  }
  parser[kOnExecute] =
    onParserExecute.bind(undefined, this, socket, parser, state);

  socket._paused = false;
}, listening=() => {
        logger.debug(`Supervisor listening at ${this._server.address().address}:${this._server.address().port}.`);
      }, error=[(err) => {
        logger.error('SUPERVISOR error', err);
      }, (err) => {
        if (err.code === 'EADDRINUSE') {
          logger.error(`${name} (${this.config[name]}) is already in use`);
        } else {
          logger.error(err);
        }
      }], clientError=(err, socket) => {
        logger.error('SUPERVISOR clientError', err, socket);
      }, _eventsCount=5, _maxListeners=undefined, _connections=1, reading=false, $ref=$["server"], onread=null, onconnection=function onconnection(err, clientHandle) {
  var handle = this;
  var self = handle.owner;

  debug('onconnection');

  if (err) {
    self.emit('error', errnoException(err, 'accept'));
    return;
  }

  if (self.maxConnections && self._connections >= self.maxConnections) {
    clientHandle.close();
    return;
  }

  var socket = new Socket({
    handle: clientHandle,
    allowHalfOpen: self.allowHalfOpen,
    pauseOnCreate: self.pauseOnConnect
  });
  socket.readable = socket.writable = true;


  self._connections++;
  socket.server = self;
  socket._server = self;

  ;
  ;
  ;
  self.emit('connection', socket);
}, writeQueueSize=0, _usingSlaves=false, _slaves=[], _unref=false, allowHalfOpen=true, pauseOnConnect=false, httpAllowHalfOpen=false, timeout=120000, keepAliveTimeout=5000, _pendingResponseData=0, maxHeadersCount=null, _connectionKey=4:127.0.0.1:5000, $ref=$["server"], _idleTimeout=120000, $ref=$, $ref=$, 0=function listOnTimeout() {
  var list = this._list;
  var msecs = list.msecs;

  if (list.nextTick) {
    list.nextTick = false;
    process.nextTick(listOnTimeoutNT, list);
    return;
  }

  debug('timeout callback %d', msecs);

  var now = TimerWrap.now();
  debug('now: %d', now);

  var diff, timer;
  while (timer = L.peek(list)) {
    diff = now - timer._idleStart;

    // Check if this loop iteration is too early for the next timer.
    // This happens if there are more timers scheduled for later in the list.
    if (diff < msecs) {
      var timeRemaining = msecs - (TimerWrap.now() - timer._idleStart);
      if (timeRemaining < 0) {
        timeRemaining = 1;
      }
      this.start(timeRemaining);
      debug('%d list wait because diff is %d', msecs, diff);
      return;
    }

    // The actual logic for when a timeout happens.

    L.remove(timer);
    assert(timer !== L.peek(list));

    if (!timer._onTimeout) {
      if (async_hook_fields[kDestroy] > 0 && !timer._destroyed &&
            typeof timer[async_id_symbol] === 'number') {
        emitDestroy(timer[async_id_symbol]);
        timer._destroyed = true;
      }
      continue;
    }

    var domain = timer.domain;
    if (domain) {

      // If the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/nodejs/node-v0.x-archive/issues/2631
      if (domain._disposed)
        continue;

      domain.enter();
    }

    tryOnTimeout(timer, list);

    if (domain)
      domain.exit();
  }

  // If `L.peek(list)` returned nothing, the list was either empty or we have
  // called all of the timer timeouts.
  // As such, we can remove the list and clean up the TimerWrap C++ handle.
  debug('%d list empty', msecs);
  assert(L.isEmpty(list));

  // Either refedLists[msecs] or unrefedLists[msecs] may have been removed and
  // recreated since the reference to `list` was created. Make sure they're
  // the same instance of the list before destroying.
  if (list._unrefed === true && list === unrefedLists[msecs]) {
    delete unrefedLists[msecs];
  } else if (list === refedLists[msecs]) {
    delete refedLists[msecs];
  }

  // Do not close the underlying handle if its ownership has changed
  // (e.g it was unrefed in its callback).
  if (this.owner)
    return;

  this.close();
}, $ref=$["_idleNext"], _unrefed=true, msecs=120000, nextTick=false, $ref=$["_idleNext"], _idleStart=107933, _destroyed=false, 0=function parserOnHeaders(headers, url) {
  // Once we exceeded headers limit - stop collecting them
  if (this.maxHeaderPairs <= 0 ||
      this._headers.length < this.maxHeaderPairs) {
    this._headers = this._headers.concat(headers);
  }
  this._url += url;
}, 1=function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
                                 url, statusCode, statusMessage, upgrade,
                                 shouldKeepAlive) {
  var parser = this;

  if (!headers) {
    headers = parser._headers;
    parser._headers = [];
  }

  if (!url) {
    url = parser._url;
    parser._url = '';
  }

  parser.incoming = new IncomingMessage(parser.socket);
  parser.incoming.httpVersionMajor = versionMajor;
  parser.incoming.httpVersionMinor = versionMinor;
  parser.incoming.httpVersion = `${versionMajor}.${versionMinor}`;
  parser.incoming.url = url;

  var n = headers.length;

  // If parser.maxHeaderPairs <= 0 assume that there's no limit.
  if (parser.maxHeaderPairs > 0)
    n = Math.min(n, parser.maxHeaderPairs);

  parser.incoming._addHeaderLines(headers, n);

  if (typeof method === 'number') {
    // server only
    parser.incoming.method = methods[method];
  } else {
    // client only
    parser.incoming.statusCode = statusCode;
    parser.incoming.statusMessage = statusMessage;
  }

  if (upgrade && parser.outgoing !== null && !parser.outgoing.upgrading) {
    // The client made non-upgrade request, and server is just advertising
    // supported protocols.
    //
    // See RFC7230 Section 6.7
    upgrade = false;
  }

  parser.incoming.upgrade = upgrade;

  var skipBody = 0; // response to HEAD or CONNECT

  if (!upgrade) {
    // For upgraded connections and CONNECT method request, we'll emit this
    // after parser.execute so that we can capture the first part of the new
    // protocol.
    skipBody = parser.onIncoming(parser.incoming, shouldKeepAlive);
  }

  if (typeof skipBody !== 'number')
    return skipBody ? 1 : 0;
  else
    return skipBody;
}, 2=function parserOnBody(b, start, len) {
  var parser = this;
  var stream = parser.incoming;

  // if the stream has already been removed, then drop it.
  if (!stream)
    return;

  var socket = stream.socket;

  // pretend this was the result of a stream._read call.
  if (len > 0 && !stream._dumped) {
    var slice = b.slice(start, start + len);
    var ret = stream.push(slice);
    if (!ret)
      readStop(socket);
  }
}, 3=function parserOnMessageComplete() {
  var parser = this;
  var stream = parser.incoming;

  if (stream) {
    stream.complete = true;
    // Emit any trailing headers.
    var headers = parser._headers;
    if (headers) {
      parser.incoming._addHeaderLines(headers, headers.length);
      parser._headers = [];
      parser._url = '';
    }

    // For emit end event
    stream.push(null);
  }

  // force to read the next incoming message
  readStart(parser.socket);
}, 4=function () { [native code] }, _headers=[], _url=, _consumed=true, $ref=$, incoming=null, outgoing=null, maxHeaderPairs=2000, onIncoming=function () { [native code] }, on=function socketOnWrap(ev, fn) {
  var res = net.Socket.prototype.on.call(this, ev, fn);
  if (!this.parser) {
    this.on = net.Socket.prototype.on;
    return res;
  }

  if (ev === 'data' || ev === 'readable')
    unconsume(this.parser, this);

  return res;
}, _paused=false, read=function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading)
      n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended)
      state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended)
      endReadable(this);
  }

  if (ret !== null)
    this.emit('data', ret);

  return ret;
}, _consuming=true
2018-04-07T12:46:42.834Z - info: User function triggered, starting execution
PROPFIND
2018-04-07T12:46:42.835Z - info: Execution took 0 ms, user function completed successfully
2018-04-07T12:47:11.984Z - info: Worker for demo closed due to file changes.
2018-04-07T12:47:11.985Z - info: Worker for appointment closed due to file changes.
2018-04-07T12:53:50.683Z - info: User function triggered, starting execution
2018-04-07T12:53:50.688Z - info: Execution took 6 ms, user function completed successfully
2018-04-07T12:53:50.706Z - info: User function triggered, starting execution
2018-04-07T12:53:50.709Z - info: request.body:  { machineType: 'Laundrymachine',
  machine: 'A1',
  time: 8,
  room: 'A',
  idToken: 'eyJhbGciOiJSUzI1NiIsImtpZCI6IjZlYThhZmIwMjFjMjEzMDhjNzkzMDI2ZTMzNDA4ZGI3MDc2ODc0MWEifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vZmlyLTUzMWY0IiwibmFtZSI6IjQwMSIsImF1ZCI6ImZpci01MzFmNCIsImF1dGhfdGltZSI6MTUyMzEwMjQ5NiwidXNlcl9pZCI6IjNoYkIyY1FiNndodnRRdjJUdFhEbnlxZ1NEZjIiLCJzdWIiOiIzaGJCMmNRYjZ3aHZ0UXYyVHRYRG55cWdTRGYyIiwiaWF0IjoxNTIzMTAyNDk2LCJleHAiOjE1MjMxMDYwOTYsImVtYWlsIjoieW9zaC5uYWhhckBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsImZpcmViYXNlIjp7ImlkZW50aXRpZXMiOnsiZW1haWwiOlsieW9zaC5uYWhhckBnbWFpbC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.CY5MiK1ofuitSMPkcaSx-aTAN26i-H2QGDisO0VpnB22JcUIzKFYC5OWBWNK6KQ8OLTACZiO4grJ6CglvCMZ5U0CreY_mVN9oPsDuE6knc5jnprG9N9V565jdJtiUysI-u71TrzpFPzrRgTjBgfoJlfT-Kzern0XL5VXg74OJiyovSuoXYyz0cseFDCPbY7Ae3WEaWCJ2toImKSrjgPU8POKWYuxCTqsC_cZZfFKPcTfUwgq3rTRauqHUhrYzirdGzqVVtmjbt3dbP6YzMZNybF6qomIxsoQjpTwaZdMZ-3opRVuzRpSF60RF8FBhPq2f0Vkto0-y0XknnzXSi2OlQ',
  date: '26-04-2018',
  houseNumber: '-' }
2018-04-07T12:53:50.823Z - info: 3hbB2cQb6whvtQv2TtXDnyqgSDf2
2018-04-07T12:53:50.824Z - info: decodedIdToken: [object Object]
signedInUserUid 3hbB2cQb6whvtQv2TtXDnyqgSDf2
2018-04-07T12:53:50.845Z - info: Execution took 138 ms, user function completed successfully
2018-04-07T12:53:52.118Z - info: counter 0
2018-04-07T12:53:52.242Z - info: houseNumber -
2018-04-07T12:53:52.495Z - info: here
